<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="SCD1Merge">
    <update id="changesBasedMergeFindDiffs" parameterType="com.arcesium.swiftlake.commands.SCD1MergeProperties">
        COPY(
            WITH diffs AS (
            SELECT
                CASE
                <if test=" operationTypeColumn != null ">
                    WHEN me.__candidate__ AND other.__candidate__ AND ${operationTypeColumn} = ${deleteOperationValue} THEN 'D'
                </if>
                    WHEN me.__candidate__ AND other.__candidate__ THEN 'U'
                    ELSE 'N'
                END AS __operation_type__,
                me.*,
                other.file_row_number AS __other_file_row_number__
            FROM
            (
                SELECT *, CASE WHEN ${boundaryCondition} THEN True ELSE False END AS __candidate__
                FROM ${destinationTableName} me
            ) me
            LEFT OUTER JOIN (
                SELECT *, True AS __candidate__ FROM ${sourceTableName}
            ) other ON (me.__candidate__=other.__candidate__ AND <include refid="Common.keyColumnJoin"/>)
            )
            SELECT * FROM diffs
        ) TO ${diffsFilePath} (FORMAT 'PARQUET', CODEC '${compression}', FILENAME_PATTERN "data_{uuid}", PARTITION_BY (__operation_type__))
    </update>

    <update id="saveDistinctFileNamesForChangesMerge" parameterType="Map">
        COPY (
            SELECT DISTINCT filename
            FROM ${diffsFilePath}
            WHERE __operation_type__ != 'N'
        ) TO '${modifiedFileNamesFilePath}' (FORMAT 'PARQUET', CODEC '${compression}')
    </update>

    <select id="getFileNames" parameterType="String" resultType="String">
        SELECT filename FROM '${value}'
    </select>

    <update id="changesBasedMergeResults" parameterType="com.arcesium.swiftlake.commands.SCD1MergeProperties">
        WITH updates AS (
            SELECT
            <foreach collection="allColumns" item="element" index="index"  open = "" separator="," >
                ${element}
            </foreach>
            FROM ${sourceTableName}
        <if test=" operationTypeColumn != null ">
            WHERE ${operationTypeColumn} != ${deleteOperationValue}
        </if>
            <if test="!appendOnly and diffsFilePath != null">
                UNION ALL BY NAME
                SELECT
                <foreach collection="allColumns" item="element" index="index"  open = "" separator="," >
                    ${element}
                </foreach>
                FROM ${diffsFilePath}
                WHERE __operation_type__ = 'N' AND filename IN (SELECT filename FROM '${modifiedFileNamesFilePath}')
            </if>
        )
        SELECT * FROM updates
    </update>

    <update id="snapshotBasedMergeAppendOnly" parameterType="com.arcesium.swiftlake.commands.SCD1MergeProperties">
        SELECT
        <foreach collection="allColumns" item="element" index="index" open="" separator=",">
            ${element}
        </foreach>
        FROM ${sourceTableName}
    </update>

    <update id="snapshotBasedMergeFindDiffs" parameterType="com.arcesium.swiftlake.commands.SCD1MergeProperties">
        COPY(
            WITH diffs AS (
                SELECT
                <!--
                    This CASE statement determines the operation type for each record by comparing source and target.
                    Order of the below conditions is very important for correct operation detection.
                -->
                CASE
                    <!-- Case 1: INSERT - If record exists in source but not in target (source is new) -->
                    WHEN me.__candidate__ IS NULL THEN 'I'
                    <!-- Case 2: UPDATE - If record exists in both source and target, but values differ -->
                    WHEN me.__candidate__ AND other.__candidate__ AND (<include refid="valueColumnsDiff"/>) THEN 'U'
                    <!-- Case 3: DELETE - If record exists in target but not in source (source is missing) -->
                    WHEN me.__candidate__ AND other.__candidate__ IS NULL THEN 'D'
                    <!-- Case 4: NO CHANGE - If record exists in both with matching values OR if records are outside the table filter boundary -->
                    ELSE 'N'
                END AS __operation_type__,
                me.*,
                <foreach collection="allColumns" item="element" index="index"  open = "" separator="," >
                    other.${element} AS __other_${element}
                </foreach>,
                other.file_row_number AS __other_file_row_number__
                FROM
                (
                    SELECT *, CASE WHEN ${boundaryCondition} THEN True ELSE False END AS __candidate__
                    FROM ${destinationTableName}
                ) me
                FULL OUTER JOIN (
                    SELECT *, True AS __candidate__ FROM ${sourceTableName}
                ) other ON (me.__candidate__=other.__candidate__ AND <include refid="Common.keyColumnJoin"/> )
            ),
            diffs_modified AS (
                SELECT * REPLACE(
                    <foreach collection="allColumns" item="element" index="index"  open = "" separator="," >
                        CASE WHEN __operation_type__='N' THEN NULL ELSE __other_${element} END AS __other_${element}
                    </foreach>
                )
                FROM diffs
            )
            SELECT * FROM diffs_modified
        ) TO ${diffsFilePath} (FORMAT 'PARQUET', CODEC '${compression}', FILENAME_PATTERN "data_{uuid}", PARTITION_BY (__operation_type__))
    </update>

    <update id="saveDistinctFileNamesForSnapshotMerge" parameterType="Map">
        COPY (
            SELECT DISTINCT filename
            FROM ${diffsFilePath}
            WHERE filename IS NOT NULL AND __operation_type__ NOT IN ('N')
        ) TO '${modifiedFileNamesFilePath}' (FORMAT 'PARQUET', CODEC '${compression}')
    </update>

    <update id="snapshotBasedMergeResults" parameterType="com.arcesium.swiftlake.commands.SCD1MergeProperties">
        SELECT
            <foreach collection="allColumns" item="element" index="index"  open = "" separator="," >
                __other_${element} AS ${element}
            </foreach>,
        FROM ${diffsFilePath}
        WHERE __operation_type__ IN ('I', 'U')

        UNION ALL BY NAME

        SELECT
            <foreach collection="allColumns" item="element" index="index"  open = "" separator="," >
                ${element}
            </foreach>
        FROM ${diffsFilePath}
        WHERE __operation_type__ = 'N' AND filename IN (SELECT filename FROM '${modifiedFileNamesFilePath}')
    </update>

    <sql id="valueColumnsDiff">
        <foreach collection="valueColumns" item="element" index="index"  open = "" separator=" OR" >
            <bind name="__delta__" value="null" />
            <bind name="__null_value__" value="null" />
            <if test="valueColumnMaxDeltaValues != null">
                <bind name="__delta__" value="valueColumnMaxDeltaValues[element]" />
            </if>
            <if test="valueColumnNullReplacements != null">
                <bind name="__null_value__" value="valueColumnNullReplacements[element]" />
            </if>
            <choose>
                <when test="__delta__ != null">
                    abs(coalesce(me.${element},0) - coalesce(other.${element},0)) > ${__delta__}
                </when>
                <when test="__null_value__ != null">
                    coalesce(me.${element},${__null_value__}) IS DISTINCT FROM coalesce(other.${element},${__null_value__})
                </when>
                <otherwise>
                    me.${element} IS DISTINCT FROM other.${element}
                </otherwise>
            </choose>
        </foreach>
    </sql>
</mapper>
